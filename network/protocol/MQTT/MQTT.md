> [MQTT入门 菜鸟教程](https://www.runoob.com/w3cnote/mqtt-intro.html)
>
> 

## MQTT 协议简介

MQTT（Message Queuing Telemetry Transport）是一种基于发布/订阅模式的消息传输协议，设计用于在资源受限的设备和低带宽、不稳定的网络环境中进行通信。MQTT 协议的主要特点包括：

- **轻量级和高效**：MQTT 协议的报文格式非常简单，占用带宽小，适用于物联网（IoT）、移动应用等对网络带宽和功耗要求严格的场景。
- **发布/订阅模式**：MQTT 使用发布/订阅的通信模式，设备（客户端）通过向特定主题发布消息或订阅主题来接收消息。
- **可靠的消息传输**：支持三种服务质量（QoS）等级，分别为“最多一次”（0）、“至少一次”（1）和“只有一次”（2），确保消息的传递可靠性。
- **灵活的主题结构**：MQTT 允许使用层级主题和通配符进行消息过滤和订阅，适应复杂的通信需求。

## MQTT 协议版本

MQTT（Message Queuing Telemetry Transport）是一个轻量级的消息传输协议，广泛应用于物联网（IoT）设备、嵌入式系统和移动应用中。MQTT 设计用于在带宽有限、高延迟或不稳定的网络环境下运行。以下是 MQTT 的几个常用版本的介绍：

### 1. **MQTT v3.1**

- **发布日期**: 2010年
- 特点:
  - 最初由 IBM 和 Eurotech 开发，作为事实上的行业标准。
  - 提供基本的发布/订阅消息传输机制，适合低带宽和高延迟的网络环境。
  - 定义了基本的 `CONNECT`、`PUBLISH`、`SUBSCRIBE`、`UNSUBSCRIBE`、`DISCONNECT` 等报文类型。
  - 支持 QoS (服务质量) 级别：0、1、2，分别对应最多一次、至少一次和仅一次的消息传递语义。
- 局限性:
  - 规范不够详细，容易导致不同实现之间的互操作性问题。
  - 缺乏正式标准化，协议名称为 `MQIsdp`。

### 2. **MQTT v3.1.1**

- **发布日期**: 2014年
- 特点:
  - 由 OASIS 标准委员会批准和发布，成为正式的行业标准。
  - 解决了 v3.1 版本中的一些不明确之处，增强了协议的清晰性和互操作性。
  - 改进了错误处理机制，特别是在 `CONNACK` 报文的返回码上。
  - 改进了连接保持（Keep Alive）机制，更明确地规定了超时处理。
  - 协议名称更改为 `MQTT`，版本号字段值为 `0x04`。
- 优点:
  - 更加稳健和清晰的协议规范。
  - 增强了不同设备和平台之间的兼容性。
- **广泛应用**: 是目前最广泛使用的 MQTT 版本，适用于大多数物联网和嵌入式应用。

### 3. **MQTT v5.0**

- **发布日期**: 2019年
- 特点:
  - 由 OASIS 发布的最新版本，旨在增强灵活性、扩展性和错误处理能力。
  - 引入了属性（Properties）机制，允许在报文中携带更多的元数据。
  - 增加了用户自定义的错误代码，增强了错误处理的灵活性。
  - 支持消息延迟投递（Message Expiry）和响应主题（Response Topic），提高了应用的灵活性。
  - 引入了共享订阅和请求/响应模式，优化了客户端和服务器的交互。
- 优点:
  - 更强大的功能和扩展性，适应更多复杂的应用场景。
  - 提高了对大规模分布式系统的支持能力。
- 局限性:
  - 由于功能的增强，协议的复杂性也有所增加，可能不适合资源非常受限的设备。
- **适用场景**: 适用于对扩展性和灵活性有较高要求的现代物联网应用。

### 4. **MQTT-SN (MQTT for Sensor Networks)**

- **概述**: 这是 MQTT 的一个变种，专为低功耗、低带宽的无线传感器网络（WSN）设计。
- 特点:
  - 支持广播和单播消息传输。
  - 支持节点的动态注册和发现。
  - 减少了协议开销，适合资源极其有限的设备。
- **适用场景**: 无线传感器网络、低功耗物联网设备。

### 总结

- **MQTT v3.1.1** 是目前最广泛使用的版本，适合大多数物联网和嵌入式应用。
- **MQTT v5.0** 引入了更多功能和灵活性，适用于复杂的物联网场景，但可能不适合资源非常受限的设备。
- **MQTT v3.1** 是较早的版本，仍在一些老旧系统中使用，但不建议用于新开发的项目。
- **MQTT-SN** 专为无线传感器网络设计，适用于非常资源受限的环境。

根据具体的应用场景和设备资源，选择合适的 MQTT 版本是关键。

## MQTT 协议嵌入式库

不同版本的 MQTT 协议在嵌入式系统中有不同的库实现，这些库通常经过优化，以适应资源受限的环境。以下是各个 MQTT 版本常用的嵌入式库：

### 1. **MQTT v3.1**

- **libemqtt**
  - **概述**: `libemqtt` 是一个轻量级的 C 语言 MQTT v3.1 库，适用于嵌入式系统。
  - 特点:
    - 支持 MQTT v3.1 协议。
    - 设计简单，适合资源受限的 MCU。
  - **适用场景**: 资源非常有限的嵌入式项目。
  - **GitHub**: [libemqtt](https://github.com/menudoproblema/libemqtt)
- **Mosquitto Embedded C**
  - **概述**: Mosquitto 是一个流行的 MQTT 消息代理，也提供了一个轻量级的嵌入式 C 客户端库。
  - 特点:
    - 支持 MQTT v3.1 和 v3.1.1 协议。
    - 适合内存和处理能力有限的设备。
  - **适用场景**: 需要一个轻量级且稳定的嵌入式 MQTT 客户端。
  - **GitHub**: [Mosquitto C library](https://github.com/eclipse/mosquitto)

### 2. **MQTT v3.1.1**

- **Eclipse Paho Embedded C**
  - **概述**: Paho 是 Eclipse 基金会下的一个开源项目，提供了多个 MQTT 客户端库，包括一个适用于嵌入式系统的 C 语言版本。
  - 特点:
    - 完全支持 MQTT v3.1.1 协议。
    - 支持多种操作系统，包括 FreeRTOS，也可用于裸机系统。
    - 提供了非阻塞和阻塞模式。
  - **适用场景**: 需要支持 v3.1.1 的嵌入式项目，尤其是基于 FreeRTOS 或其他 RTOS 的系统。
  - **GitHub**: [Paho Embedded C](https://github.com/eclipse/paho.mqtt.embedded-c)
- **Mbed MQTT**
  - **概述**: Mbed MQTT 是为 Arm Mbed OS 设计的 MQTT v3.1.1 客户端库，但也可以移植到其他嵌入式平台。
  - 特点:
    - 支持 MQTT v3.1.1 协议。
    - 提供简单易用的 API，易于集成到基于 Arm Mbed 的项目中。
    - 支持 TLS/SSL 安全通信。
  - **适用场景**: 使用 Arm Mbed OS 或需要安全通信的嵌入式系统。
  - **GitHub**: [Mbed MQTT](https://github.com/ARMmbed/mbed-mqtt)
- **wolfMQTT**
  - **概述**: wolfMQTT 是一个专为嵌入式设备设计的 MQTT 客户端库，由 wolfSSL 提供。
  - 特点:
    - 支持 MQTT v3.1.1 协议。
    - 集成了 wolfSSL 库，支持安全通信。
    - 轻量级，设计用于资源受限的环境。
  - **适用场景**: 需要高安全性和轻量级 MQTT 客户端的嵌入式项目。
  - **GitHub**: [wolfMQTT](https://github.com/wolfSSL/wolfMQTT)

### 3. **MQTT v5.0**

- **Eclipse Paho C**
  - **概述**: Paho C 客户端是一个支持 MQTT v5.0 的库，适用于多种平台，包括嵌入式系统。
  - 特点:
    - 支持 MQTT v5.0 协议。
    - 提供了完整的 MQTT 功能，包括属性（Properties）和响应主题（Response Topics）。
    - 适合嵌入式系统，但相对于 v3.1.1 的实现，复杂性略高。
  - **适用场景**: 需要支持最新 MQTT v5.0 特性的嵌入式项目。
  - **GitHub**: [Paho C](https://github.com/eclipse/paho.mqtt.c)
- **Mosquitto**
  - **概述**: Mosquitto 也是一个支持 MQTT v5.0 的库，广泛用于嵌入式系统。
  - 特点:
    - 轻量级，适合资源受限的设备。
    - 支持 MQTT v3.1、v3.1.1 和 v5.0 协议。
    - 提供完整的 MQTT 功能，适合需要使用最新协议的项目。
  - **适用场景**: 需要使用 MQTT v5.0 协议的嵌入式系统。
  - **GitHub**: [Mosquitto](https://github.com/eclipse/mosquitto)

### 4. **MQTT-SN**

- **RSMB (Really Small Message Broker)**
  - **概述**: RSMB 是一个轻量级的 MQTT-SN 消息代理和客户端库，适合无线传感器网络和极其资源受限的环境。
  - 特点:
    - 支持 MQTT-SN 协议。
    - 设计简洁，适合低功耗、低带宽的设备。
  - **适用场景**: 无线传感器网络或其他需要使用 MQTT-SN 的项目。
  - **GitHub**: [RSMB](https://github.com/eclipse/mosquitto.rsmb)
- **NanoMQ**
  - **概述**: NanoMQ 是一个专门为物联网设计的 MQTT 和 MQTT-SN 消息代理，支持多种嵌入式平台。
  - 特点:
    - 支持 MQTT-SN 协议。
    - 高性能和轻量级，适合资源受限的物联网设备。
  - **适用场景**: 需要支持 MQTT-SN 协议的嵌入式系统。
  - **GitHub**: [NanoMQ](https://github.com/nanomq/nanomq)

### 总结

- **MQTT v3.1**: 适合资源极度有限的嵌入式系统，`libemqtt` 和 `Mosquitto Embedded C` 是常用选择。
- **MQTT v3.1.1**: 广泛应用于现代嵌入式系统中，`Paho Embedded C`、`Mbed MQTT` 和 `wolfMQTT` 是常用的嵌入式库。
- **MQTT v5.0**: 对于需要更多功能和扩展性的嵌入式系统，`Paho C` 和 `Mosquitto` 是良好的选择。
- **MQTT-SN**: 专为无线传感器网络设计的轻量级协议，`RSMB` 和 `NanoMQ` 是适合的库。

## MQTT 协议的工作流程

1. **连接（CONNECT）**：客户端向 MQTT 服务器（通常称为“代理”或“Broker”）发送连接请求，包含客户端标识符、用户名、密码、遗嘱消息等信息。
2. **连接确认（CONNACK）**：服务器响应连接请求，确认连接是否成功，以及是否有会话需要恢复。
3. **发布消息（PUBLISH）**：客户端发布消息到某个主题，消息通过代理转发给订阅该主题的所有客户端。
4. **订阅主题（SUBSCRIBE）**：客户端向服务器发送订阅请求，指定要接收的消息主题。
5. **订阅确认（SUBACK）**：服务器确认订阅请求，指示订阅是否成功。
6. **取消订阅（UNSUBSCRIBE）**：客户端取消对某个主题的订阅。
7. **取消订阅确认（UNSUBACK）**：服务器确认取消订阅请求。
8. **心跳检测（PINGREQ 和 PINGRESP）**：客户端和服务器通过心跳消息维持连接的活跃状态。
9. **断开连接（DISCONNECT）**：客户端主动断开与服务器的连接。

> MQTT v3.1 和 v3.1.1 都是轻量级的消息传输协议，主要用于物联网设备之间的通信。虽然这两个版本之间存在一些差异，但它们的基本协议格式在 CONNECT、CONNACK、PUBLISH、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK、PINGREQ、PINGRESP 和 DISCONNECT 报文的结构上大致相同。

以下是这两个版本的各类报文格式的详细说明：

### 1. **CONNECT 报文**

CONNECT 报文用于客户端与服务器建立连接。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称               | 描述                                                         |
| -------- | ------------------ | ------------------------------------------------------------ |
| 0        | 固定报头 (1字节)   | 报文类型（1-4位），剩余长度（第2字节之后）                   |
| 1        | 剩余长度           | 剩余报文长度，使用可变长度编码                               |
| 2-3      | 协议名长度         | 表示协议名的长度（高字节在前），MQIsdp（v3.1），MQTT（v3.1.1） |
| 4-7      | 协议名             | “MQIsdp” 或 “MQTT”                                           |
| 8        | 协议版本号         | 0x03（v3.1），0x04（v3.1.1）                                 |
| 9        | 连接标志           | 包含连接标志位，如清除会话、用户名标志、密码标志、Will 标志等 |
| 10-11    | 保持连接时间       | 心跳保持时间（以秒为单位），表示客户端和服务器之间的最长允许空闲时间 |
| 12-...   | 可变头部和有效载荷 | 包含客户端标识符、Will Topic、Will Message、用户名、密码等字段 |

#### **CONNECT 报文格式**

`CONNECT` 报文由以下几部分组成：

1. 固定头部（Fixed Header）
2. 可变头部（Variable Header）
3. 有效载荷（Payload）

##### **1. 固定头部**

- **报文类型**：4 位，用于指定 MQTT 报文的类型，对于 `CONNECT` 报文，其值为 `0001`。
- **剩余长度**：表示可变头部和有效载荷的字节总数。

##### **2. 可变头部**

可变头部包含协议名称、协议级别、连接标志和保持连接（Keep Alive）计时器。

- **协议名（Protocol Name）**：例如 "MQTT"。
- **协议级别（Protocol Level）**：例如 `0x04` 对应 MQTT v3.1.1。
- **连接标志（Connect Flags）**：这是一个 1 字节的字段，用于设置包括遗嘱消息在内的多个连接参数。
  - **用户名标志（User Name Flag）**：位于第 7 位，用于指示是否包含用户名。
  - **密码标志（Password Flag）**：位于第 6 位，用于指示是否包含密码。
  - **遗嘱标志（Will Flag）**：位于第 2 位。如果设置为 `1`，表示启用遗嘱消息；如果为 `0`，则不启用。
  - **遗嘱 QoS（Will QoS）**：位于第 3 和第 4 位，用于指定遗嘱消息的服务质量（QoS）。
  - **遗嘱保留标志（Will Retain）**：位于第 5 位，指示遗嘱消息是否保留。
  - **清理会话标志（Clean Session）**：位于第 1 位，用于指示是否清理客户端的状态信息。
- **保持连接（Keep Alive）**：一个 2 字节的字段，用于设置客户端和服务器之间的保持连接时间间隔。

##### **3. 有效载荷**

有效载荷中包含的内容与连接标志中设置的字段相关，具体包括：

- **客户端标识符（Client Identifier）**：标识客户端的唯一标识符。
- **遗嘱主题（Will Topic）**：如果启用了遗嘱消息，这里会包含遗嘱消息的主题。
- **遗嘱消息（Will Message）**：如果启用了遗嘱消息，这里会包含遗嘱消息的内容。
- **用户名（User Name）**：如果连接标志中设置了用户名标志，这里会包含用户名。
- **密码（Password）**：如果连接标志中设置了密码标志，这里会包含密码。

##### **遗嘱消息在 CONNECT 报文中的设置**

假设你要设置一个带有遗嘱消息的 `CONNECT` 报文，流程如下：

1. **将 Will Flag 设置为 1**：表示启用遗嘱消息。
2. **设置 Will QoS**：指定遗嘱消息的服务质量等级。
3. **设置 Will Retain**：指定遗嘱消息是否保留。
4. **指定 Will Topic 和 Will Message**：在有效载荷部分填入遗嘱消息的主题和内容。

### 2. **CONNACK 报文**

CONNACK 报文是服务器对客户端发送的 CONNECT 报文的确认。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称           | 描述                                    |
| -------- | -------------- | --------------------------------------- |
| 0        | 固定报头       | 报文类型为 0x20                         |
| 1        | 剩余长度       | 0x02，表示剩余报文长度为 2 字节         |
| 2        | 连接确认标志位 | 0x00 表示无效，0x01 表示清除会话标志    |
| 3        | 返回代码       | 0x00 表示连接已接受，其他值表示错误代码 |

返回代码错误代码举例：

- 0x01: 不支持的协议版本
- 0x02: 无效的客户端标识符
- 0x03: 服务器不可用
- 0x04: 无效的用户名或密码
- 0x05: 未授权

### 3. **PUBLISH 报文**

PUBLISH 报文用于客户端和服务器之间传递应用消息。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称       | 描述                                                |
| -------- | ---------- | --------------------------------------------------- |
| 0        | 固定报头   | 报文类型为 0x30（具体还包含 QoS、DUP、Retain 标志） |
| 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                      |
| 2-3      | 主题名长度 | 主题名的长度（高字节在前）                          |
| 4-...    | 主题名     | 包含主题的字符串                                    |
| ...      | 报文标识符 | 若 QoS > 0，包含报文标识符                          |
| ...      | 消息内容   | 有效载荷，包含应用层的数据                          |

在 MQTT 协议中，`PUBLISH` 报文是用于客户端发布消息的关键数据包。该报文允许客户端向服务器发送消息，并且服务器根据订阅关系将消息转发给其他客户端。下面是 MQTT `PUBLISH` 报文的格式和详细字段解释。

#### **PUBLISH 报文格式**

`PUBLISH` 报文由多个部分组成，包括固定报头、可变报头和负载。

##### **1. 固定报头（Fixed Header）**

- **字节 1**：报文类型和标志位
  - 位 7-4：消息类型 (PUBLISH 为 `0011`, 即 0x3)
  - 位 3：DUP 标志（1 表示可能重复传输，0 表示首次发送）
  - 位 2-1：QoS 等级
    - `00`：QoS 0 (At most once)
    - `01`：QoS 1 (At least once)
    - `10`：QoS 2 (Exactly once)
    - `11`：保留，不能使用
  - 位 0：RETAIN 标志（1 表示消息应保留，0 表示不保留）
- **字节 2+**：剩余长度（Remaining Length）
  - 剩余长度表示报文后续部分的字节总数，使用可变长度编码。

##### **2. 可变报头（Variable Header）**

- **主题名长度（Topic Name Length）**：2 字节
- **主题名（Topic Name）**：UTF-8 编码的字符串
- **报文标识符（Packet Identifier，QoS > 0 时使用）**：2 字节，用于标识该 `PUBLISH` 报文。

##### **3. 负载（Payload）**

- 实际消息内容，内容可以是任意字节序列，长度为剩余长度减去固定报头和可变报头的长度。

#### **PUBLISH 报文示例**

1. - 假设我们要发布一条消息，主题是 `sensor/data`，消息内容为 `{"temp":22}`，使用 QoS 1（确保消息至少一次送达）。以下是一个示例报文的结构和解析：

     ```mathematica
     32 16 00 0B 73 65 6E 73 6F 72 2F 64 61 74 61 00 7B 22 74 65 6D 70 22 3A 32 32 7D
     ```

     1. **固定报头**：

        - ```
          0x32 = 0011 0010：
          ```

          - `0011` = PUBLISH (MQTT 消息类型)
          - DUP = 0（消息不是重复的）
          - QoS = 1（确保消息至少一次送达）
          - RETAIN = 0（不保留该消息）

        - 剩余长度为 `0x16`，即 22 字节（可变报头 + 负载的长度）。

     2. **可变报头**：

        - 主题名长度：`00 0B`，即 11 个字节
        - 主题名：`73 65 6E 73 6F 72 2F 64 61 74 61`，即 `sensor/data`
        - 报文标识符：`00 7B`，即 `123`（仅在 QoS > 0 时才有此字段）。

     3. **负载**：

        - 消息内容：`7B 22 74 65 6D 70 22 3A 32 32 7D`，即 `{"temp":22}`

#### **总结**

- **固定报头**包含消息类型和标志。
- **可变报头**根据 QoS 等级，包含主题名和报文标识符。
- **负载**是实际要发布的消息内容。

`PUBLISH` 报文是 MQTT 通信的核心，你可以通过 QoS 和 retain 标志来控制消息的可靠性和持久性。

### 4. **SUBSCRIBE 报文**

SUBSCRIBE 报文用于客户端向服务器请求订阅一个或多个主题。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称       | 描述                                                |
| -------- | ---------- | --------------------------------------------------- |
| 0        | 固定报头   | 报文类型为 0x82                                     |
| 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                      |
| 2-3      | 报文标识符 | 表示当前订阅请求的唯一标识符                        |
| 4-...    | 主题过滤器 | 主题字符串，后接订阅的 QoS（每个主题过滤器 1 字节） |

在 MQTT 协议中，`SUBSCRIBE` 报文用于客户端向服务器发送订阅请求，以订阅一个或多个主题。服务器根据该报文将未来发布在这些主题上的消息推送给订阅客户端。`SUBSCRIBE` 报文仅在 QoS 等级 1 或 2 时有效。

#### **SUBSCRIBE 报文格式**

`SUBSCRIBE` 报文由固定报头、可变报头和负载组成。

##### **1. 固定报头（Fixed Header）**

- 字节 1：报文类型和标志位
  - 位 7-4：报文类型 (SUBSCRIBE 为 `1000`, 即 0x8)
  - 位 3：DUP 标志 (一般为 0)
  - 位 2-1：QoS 等级，必须为 1 或 2
  - 位 0：保留位，必须为 0
- 字节 2+：剩余长度（Remaining Length）
  - 剩余长度表示报文后续部分的字节数，使用可变长度编码。

##### **2. 可变报头（Variable Header）**

- 报文标识符（Packet Identifier）：2 字节
  - 用于标识该 `SUBSCRIBE` 报文（在 QoS 1 或 QoS 2 时必须设置）。

##### **3. 负载（Payload）**

- 主题过滤器和 QoS 列表：
  - 每个主题过滤器为一个 UTF-8 编码的字符串，后跟 1 个字节表示 QoS 等级。
  - 负载可以包含多个主题过滤器及其 QoS。

#### **SUBSCRIBE 报文示例**

假设客户端想要订阅两个主题：`sensor/temp` 和 `sensor/humidity`，QoS 为 1 和 2，以下是一个 `SUBSCRIBE` 报文的结构示例。

```mathematica
82 16 00 10 00 0A 73 65 6E 73 6F 72 2F 74 65 6D 70 01 00 0E 73 65 6E 73 6F 72 2F 68 75 6D 69 64 69 74 79 02
```

1. **固定报头**：

   - ```
     0x82= 1000 0010
     ```

     - `1000` = SUBSCRIBE 报文类型
     - QoS = 1

   - 剩余长度为 `0x16`（22 字节）。

2. **可变报头**：

   - 报文标识符：`00 10`，即 `16`

3. **负载**：

   - 主题过滤器 1：
     - 主题名长度：`00 0A`，即 10 个字节
     - 主题名：`73 65 6E 73 6F 72 2F 74 65 6D 70`，即 `sensor/temp`
     - QoS：`01`（QoS 1）
   - 主题过滤器 2：
     - 主题名长度：`00 0E`，即 14 个字节
     - 主题名：`73 65 6E 73 6F 72 2F 68 75 6D 69 64 69 74 79`，即 `sensor/humidity`
     - QoS：`02`（QoS 2）

#### **总结**

- **固定报头**：包含报文类型和 QoS 等信息。
- **可变报头**：包含报文标识符，用于在 QoS 1 或 2 下进行响应匹配。
- **负载**：包含要订阅的主题列表及其对应的 QoS 等级。

`SUBSCRIBE` 报文允许客户端订阅多个主题，并为每个主题指定不同的 QoS，确保可靠性。

### 5. **SUBACK 报文**

SUBACK 报文是服务器对客户端发送的 SUBSCRIBE 报文的确认。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称       | 描述                                              |
| -------- | ---------- | ------------------------------------------------- |
| 0        | 固定报头   | 报文类型为 0x90                                   |
| 1        | 剩余长度   | 剩余报文长度，使用可变长度编码                    |
| 2-3      | 报文标识符 | 与 SUBSCRIBE 报文中使用的标识符相同               |
| 4-...    | 返回代码   | 订阅的 QoS 等级（每个主题过滤器对应一个返回代码） |

`SUBACK` 报文用于确认服务器已处理客户端的 `SUBSCRIBE` 请求。在 MQTT 中，客户端订阅主题时，服务器会返回一个 `SUBACK` 报文，以告知客户端是否成功订阅以及每个主题的 QoS 等级。

#### **SUBACK 报文格式**

`SUBACK` 报文由固定报头、可变报头和负载组成。

##### **1. 固定报头 (Fixed Header)**

- 字节 1：报文类型和标志位
  - 位 7-4：报文类型 (SUBACK 为 `1001`，即 0x9)
  - 位 3-0：保留位，必须为 0
- 字节 2+：剩余长度 (Remaining Length)
  - 表示可变报头和负载的字节总数，使用可变长度编码。

##### **2. 可变报头 (Variable Header)**

- 报文标识符 (Packet Identifier)：2 字节
  - 与 `SUBSCRIBE` 报文中的标识符匹配，以便客户端知道哪个订阅请求得到了回应。

##### **3. 负载 (Payload)**

- 返回码 (Return Code) 列表：
  - 每个订阅主题对应一个返回码，表示订阅是否成功以及最终分配的 QoS 等级。返回码的含义如下：
    - `0x00`：成功 - QoS 0
    - `0x01`：成功 - QoS 1
    - `0x02`：成功 - QoS 2
    - `0x80`：失败（订阅请求被服务器拒绝）

#### **SUBACK 报文示例**

假设客户端订阅了两个主题，服务器确认第一个主题订阅成功且 QoS 为 1，第二个主题订阅失败。服务器返回的 `SUBACK` 报文如下：

```
90 04 00 10 01 80
```

1. **固定报头**：
   - `0x90` = `1001 0000`：SUBACK 报文类型，无特殊标志位。
   - 剩余长度：`0x04`（4 字节）。
2. **可变报头**：
   - 报文标识符：`00 10`，即 16（与 `SUBSCRIBE` 报文中的标识符相同）。
3. **负载**：
   - 返回码列表：
     - `0x01`：第一个主题成功订阅，QoS 为 1。
     - `0x80`：第二个主题订阅失败。

#### **SUBACK 报文生成代码示例**

在 `libemqtt` 库中，解析 `SUBACK` 报文并处理订阅响应可以通过类似如下的代码实现：

```c
void mqtt_handle_suback(uint8_t *message, int message_len) {
    if (message_len < 3) {
        printf("Invalid SUBACK message\n");
        return;
    }

    // 提取报文标识符
    uint16_t packet_id = (message[2] << 8) | message[3];
    printf("SUBACK for packet id: %d\n", packet_id);

    // 解析返回码
    for (int i = 4; i < message_len; i++) {
        uint8_t return_code = message[i];
        if (return_code == 0x00) {
            printf("Subscription success: QoS 0\n");
        } else if (return_code == 0x01) {
            printf("Subscription success: QoS 1\n");
        } else if (return_code == 0x02) {
            printf("Subscription success: QoS 2\n");
        } else if (return_code == 0x80) {
            printf("Subscription failed\n");
        } else {
            printf("Unknown return code: 0x%02X\n", return_code);
        }
    }
}
```

该代码通过解析 `SUBACK` 报文的返回码，确认每个主题的订阅是否成功，并打印对应的 QoS 等级或错误信息。

#### **总结**

- **固定报头**：指明报文类型 (SUBACK) 和剩余长度。
- **可变报头**：包含与 `SUBSCRIBE` 请求匹配的报文标识符。
- **负载**：返回码列表，表示每个主题的订阅结果。

通过 `SUBACK` 报文，服务器可以向客户端反馈每个主题的订阅结果，包括 QoS 等级或订阅失败的情况。

### 6. **UNSUBSCRIBE 报文**

UNSUBSCRIBE 报文用于客户端向服务器请求取消订阅一个或多个主题。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称       | 描述                             |
| -------- | ---------- | -------------------------------- |
| 0        | 固定报头   | 报文类型为 0xA2                  |
| 1        | 剩余长度   | 剩余报文长度，使用可变长度编码   |
| 2-3      | 报文标识符 | 表示当前取消订阅请求的唯一标识符 |
| 4-...    | 主题过滤器 | 包含一个或多个主题字符串         |

### 7. **UNSUBACK 报文**

UNSUBACK 报文是服务器对客户端发送的 UNSUBSCRIBE 报文的确认。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称       | 描述                                  |
| -------- | ---------- | ------------------------------------- |
| 0        | 固定报头   | 报文类型为 0xB0                       |
| 1        | 剩余长度   | 0x02                                  |
| 2-3      | 报文标识符 | 与 UNSUBSCRIBE 报文中使用的标识符相同 |

### 8. **PINGREQ 报文**

PINGREQ 报文用于客户端向服务器发送一个“心跳”请求，以确保连接的可用性。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称     | 描述                             |
| -------- | -------- | -------------------------------- |
| 0        | 固定报头 | 报文类型为 0xC0，剩余长度为 0x00 |

### 9. **PINGRESP 报文**

PINGRESP 报文是服务器对客户端发送的 PINGREQ 报文的响应。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称     | 描述                             |
| -------- | -------- | -------------------------------- |
| 0        | 固定报头 | 报文类型为 0xD0，剩余长度为 0x00 |

### 10. **DISCONNECT 报文**

DISCONNECT 报文用于客户端或服务器主动断开连接。

#### MQTT v3.1 和 v3.1.1 格式：

| 字节偏移 | 名称     | 描述                             |
| -------- | -------- | -------------------------------- |
| 0        | 固定报头 | 报文类型为 0xE0，剩余长度为 0x00 |

### **v3.1 和 v3.1.1 之间的主要差异**

- **协议名称**: 在 CONNECT 报文中，MQTT v3.1 使用 `MQIsdp` 作为协议名称，而 MQTT v3.1.1 使用 `MQTT`。
- **协议版本号**: 在 CONNECT 报文中，MQTT v3.1 的协议版本号为 `0x03`，而 v3.1.1 的协议版本号为 `0x04`。
- **错误处理**: 在 CONNACK 报文中，MQTT v3.1.1 增强了对错误处理的支持，提供了更多明确的返回代码。

这些报文格式在实现 MQTT 客户端或服务器时至关重要，确保了设备之间的互操作性。

是的，MQTT v3.1.1 在错误处理方面确实做了一些增强，特别是在 CONNACK 报文的返回代码部分，相较于 MQTT v3.1 版本提供了更详细的错误信息。具体来说：

#### **MQTT v3.1 错误代码**

在 MQTT v3.1 中，CONNACK 报文的返回代码相对简单，只有以下几种：

- **0x00**: 连接已接受。
- **0x01**: 连接被拒绝，不支持的协议版本。
- **0x02**: 连接被拒绝，标识符不合适。
- **0x03**: 连接被拒绝，服务不可用。
- **0x04**: 连接被拒绝，无效用户名或密码。
- **0x05**: 连接被拒绝，未授权。

#### **MQTT v3.1.1 错误代码**

MQTT v3.1.1 在此基础上保留了 v3.1 的所有错误代码，并进行了规范化，同时加强了错误代码的定义和使用。v3.1.1 主要改进在于：

- **更详细的错误代码描述**: 对每个错误代码的用途和适用场景进行了更详细的规范，确保了客户端和服务器之间的一致性。
- **明确的错误返回**: 对于不支持的协议版本，v3.1.1 明确要求返回 `0x01`，而在 v3.1 中，这一错误处理不够规范化。

具体来说，MQTT v3.1.1 的错误代码仍然保持不变，但在实现细节和错误处理方面更加严谨和明确。这些改进提高了客户端和服务器之间通信的可靠性和一致性。

#### 实际应用中的影响

在实际应用中，如果一个客户端发送了不支持的协议版本号，比如在 CONNECT 报文中使用了 `0x03` 而服务器只支持 `0x04`，服务器将返回 `0x01` 表示不支持的协议版本。这种明确的错误返回让客户端可以快速了解问题所在并采取相应措施。

这种差异在设计和调试 MQTT 应用时需要特别注